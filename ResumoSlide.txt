Primeiro slide faz uma apresentação da equipe de orientadores do curso, os slides de 2 a 5 apresentam a ementa do curso e o slide 6
comenta sobre como a distribuição da nota do curso funcionará 

no slide 7, há uma apresentação do conceito de Software Configuration management ou gerenciamento de alterações, há também um questionamento
acerca da importância de gerenciar as alterações de um software.

No slide 8, alguns passos pra trás são dados no sentido de apresentar a definição de um software

No slide 9, há um retorno para o questionamento do slide 7, que passa a ser respondido, uma vez que se apresentam alguns motivos para o
Software configuration management, sendo eles: Identificação, Controle de Mudanças, Controle de Versão, Auditoria de Configuração

no slide 10 há um breve resumo da história do SCM, que é dividido em 3 períodos, nos anos 50(quando os primórdios da área surge com função militar)
entre os anos 60 e 70(A área oficialmente nasce com o seu nome atual, mas segue tendo função militar)
a partir dos anos 80(tempos atuais)

No slide 11, há a apresentação de alguns conceitos importantes, como o de Item de Confiuguração, Baseline e Auditoria de Configuração,
além de citar algumas vantagens da aplicação do SCM, como assegurar um estado saudável e rastreável do software

No slide 12, ressalta-se que todas as pessoas envolvidas num software, do desenvolvedor ao gerente, precisam ter conhecimento de SCM

no Slide 13, define-se o Controle de mudança o conceito de gerenciar e autorizar eventuais mudanças em um software, no qual possíveis mudanças
serão propostas, avaliadas e revisadas, e, só então, caso aprovadas, implementadas no código, além disso, cita como uma vantagem desse conceito
a capacidade de manter a estabiliade de um software.

No slide 14, apresenta-se o conceito de Issue, bem como as características que uma issue pode ter, além disso, há a apresentação do conceito de 
Issue Tracking, o sistema usado para gerenciar Issues.

No slide 15, aprenseta-se o conceito de Milestone, que é um grupo de Issues, além de apresentar a importância de um comitê de controle de
Mudanças, responsável por revisar, aprovar e/ou rejeitar possíveis mudanças em um projeto

No slide 16, há uma exemplificação de como uma issue seria aplicada na prática por meio do GitHub, Já nos slides 17 há uma imagem que exemplifica
um problema de não se aplicar o controle de mudanças

No slide 18, há a intrudução ao controle de versões, bem como alguns problemas que podem surgir caso esse não seja aplicado, dos quais o principal
é a não escalabilidade do projeto

No slide 19, a tecnologia GIT é citada como útil na aplicação do controle de versões

No slide 20, há a apresentação de alguns conceitos importantes como Diretório de trabalho, Repositório e Histórico de versão

No slide 21 há uma imagem cômica acerca de problemas da não implementação do controle de versões e no slide 22 há o link de um formulário
para responder acerca dos conhecimentos adquiridos na primeira aula


Aula 2: 
No slide 1 da aula 2, novamente são apresentados os orientadores do curso

No slide 2, há um retorno para a aula anterior, além de um questionamento acerca da ferramenta que se é utilizada no controle de versão
questionamento esse respondido no slide 3: GIT, Mercurial ou Subversion

No slide 4, há um foco na apresentação da tecnologia GIT, a tecnologia de controle de versão mais conhecida do mundo, de código aberto,
com uma breve história acerca de sua origem e comentários acerca de ser um sistema de controle de versão distribuido, isto é, todos os 
usuários tem acesso a todas as mudanças de todos os usuários.

No slide 5 há um tutorial de como se instalar o GIT, bem como o link para sua instalação, além da apresentação do comando Git version,
que apresenta a versão do git que se tem instalada

No slide 6 há imagens que exemplificam alguns serviços de hospedagem git mais conhecidos: Github, Gitlab e Atlassian BitBucket

No slide 7 há uma explicação mais detalhada acerca do serviço do GitHub, o mais utilizado serviço de hospedagem da tecnologia Git.
Também há um comentário acerca da presença de códigos públicos e privados no GitHub desenvolvidos pela comunidade, no qual pode-se
modificar as versões existentes e/ou utilizar os softwares para fins comerciais.

No slide 8 há uma explicação de como utilizar o GitHub por meio do VSCode

No slide 9 explica-se a diferença entre os conceitos de repositório e diretório

No slide 10 explica-se como configurar o github no VSCode por meio dos comandos de git config, associando um email e um nome

No slide 11, explica-se como criar um repositório local, criando um pasta, deslocando-se para ela e digitando git init no terminal, além
de mostrar o comando git status para verificar a situação do repositório local

No slide 12, explica-se como criar um repositório remoto no site do github por meio de um botão

No slide 13, o comando git add é introduzido como uma forma de adicionar mudanças para um commit

No slide 14, o comando git rm e algumas de suas variações são introduzidas como uma forma de cancelar mudanças a serem enviadas para commit,
algumas de suas variações são git rm --cached <nome do arquivo>, git rm --cached *.txt e git rm -r cached ., que respectivamente removem:
o arquivo especificado, todos os arquivos do tipo txt e todos os arquivos.

no slide 15, introduz-se o comando git commit -m, que envia um pacote de mudanças para o repositório, além de um questionamento acerca
do que aconteceria ao utilizar o git commit sem o "-m"

o slide 16 responde o questionamento do slide passado de forma bem humorada, ao introduzir o vim, que é aberto quando aquilo especificado
anteriormente acontece, uma ferramenta de edição de texto multiplataforma, utilizada para fazer alterações em um eventual commit

No slide 17, há uma explicação acerca de como se estabelecer uma conexão entre um repositório remoto e um repositório local, por meio do comando
git remote add origin <url>, e em seguida como alterar o repositório remoto por meio de alterações locais, por meio do comando
git push -u origin master

No slide 18 há uma explicação acerca de como se conectar diferentes repositórios, por meio do comando git clone <url https> ou <SSH ref>
também comenta-se acerca da possiblidade de clonar por meio do GitHub cli, caso este esteja instalado na máquina

no slide 19, explica-se acerca dos comandos git pull(que atualiza o repositório local com o que está no remoto) e git push(que atualiza o repositório
remoto com aquilo que está no local). Além disso, comenta-se sobre a funcionalidade do pull, que por padrão atualiza o repositório local com as informações
da branch em que se está, mas que pode ser feito de forma diferente por meio do comando git pull origin <nome da branch>

No slide 20, há um comentário mais específico acerca do comando git clone, que copia tudo no repositório ao qual se refere, inclusive todas as versões
e histórico de alterações, Há também um aviso para se tomar cuidado com as licensas, para não cometer pirataria.

No slide 21, há um resumo acerca de como se desfazer mudanças, por meio de git checkout, caso não tenha sido adicionado, git reset HEAD, caso
commit não tenha sido executado, git reset head~ caso um commit já tenha sido realizado e git revert HEAD, que é diferente dos outros, uma vez que
não desfaz efetivamente a mudança, mas prepara um novo commit com todas as mudanças desfeitas, esse novo commit teria que ser enviado em seguida

No slide 22 introduz-se o conceito de branch, bem como se locomover entre elas. git branch <nome>para criar, git checkout -b <nome> para criar e entrar
e git push --set-upstream origin <nome> para enviar um commit para uma branch remota não principal

No slide 23, expande-se acerca da funcionalidade do git checkout ao mostrar como este pode ser utilizado para se mover entre versões de uma mesma branch,
git checkout se move para o último commit, git checkout <id> se move para o commit especificado e git checkout tags <tag> se move para o commit com aquela tag

No slide 24 apresenta-se o conceito de merge, uma funcionalidade que junta diferentes branchs por meio de um commit, caso o usuário esteja na branch 1 
e execute o comando git merge branch2, criará um commit na branch 1 que se junta com a branch 2

No slide 25, as possibilidades de merge são expandidas ao introduzir a possibilidade de juntar uma branch com uma versão anterior de si mesma, com o
comando git merge --no ff <nome>

No slide 26, o comando git rebase é apresentado, contudo, é também especificado que o comando é pouco utilizado, uma vez que reescreve o histórico
dos commits, que vai contra uma das principais vantagens da tecnologia Git, que possibilita o acesso às versões passadas de um eventual software

No slide 27, um problema é apresentado ao citar a possibilidade de 2 branches mudarem determinada área do código de forma semelhante, gerando um conflito

No slide 28, uma solução é apresentada por meio do git abort, porém esse apenas procrastina o problema

No slide 29, outra solução é apresentada, que é escolher entre uma das opções de merge

já no slide 30, outra solução apresentada é reescrever manualmente aquela parte do código, resolvendo o conflito